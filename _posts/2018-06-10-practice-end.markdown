---
layout:    post
title:      "实习结束总结"
subtitle:   "The summary of practice"
date:       2018-06-10 12:00:00
author:     "scyhssm"
header-img: "img/实习.jpeg"
header-mask: 0.3
catalog:    true
tags:
    - 实习
---

>实习结束的总结

## 公司平台及架构
### 公司的管理平台
1. Confluence，知识管理

2. Jira，项目管理、任务追踪、缺陷管理

3. Bamboo，范式的CICD环境

4. Bitbucket，范式的代码仓库

### 平台基础架构
1. Prophet EE总体是要做一个SaaS系统，通过Web页面实现机器学习应用

### Prophet EE底层架构
1. 最底层的资源调度Yarn，k8s，搭建在集群之上，另外存储的底层包括HDFS、HBase、MongoDB、Redis

2. Yarn跑Spark的算子，k8s跑的是TensorFlow的算子。在底下用Kafka支持流式数据的存储。ES补充传统数据库的不足，在搜索和数据分析上提供支持

3. ElasticSearch用于全文搜索比较多，GitHub，Wiki有用到

4. ElasticSearch实时的文件存储，每个字段都能被搜索，实时分析搜索引擎

5. 倒排索引，存储在全文搜索下某个单词在一个文档或者一组文档中存储位置的映射。

6. 在底层之上抽象了资源管理（查询资源）、文件存储（存储打包的pha文件）依赖HDFS

7. PDMS、PWS、PAS、PMS功能分别负责存储、跑任务、生成应用服务、监控管理

8. 举个栗子，PWS要跑DAG，这个DAG包含了很多步骤，会牵涉到存储，特征抽取，模型训练等

9. 要从PDMS中拿prn，将prn放到PWS中的数据来源，训练结果模型和数据放到PDMS中

10. 这里会有PMS参与监控，管理资源日志报警，还可以监控pha生成的应用

11. PAS可以最终生成服务，对应客户训练出来的模型落地到具体场景

12. 顶层开发Web页面，用于客户更好的生成定制化的模型

## 项目经验
### 测试
1. 冒烟测试，在一个新版本出来的时候把功能全部过一遍，看是否有问题，没有问题可以真正开始用户测试。如果有重大问题就是版本不合格不能用户测试

2. 回归测试是以前版本中发现的BUG在新版本中验证是否存在且有没有导致其他BUG的产生

### 业务系统
写业务系统最关键的是理解业务，不能上来就想写，这是写不出好的代码的

### 学习圈及自学习
#### 自学习
1. 实际上是模型训练，但是加入了定时任务，可以不断地根据新生成的数据以及反馈数据对已生成的模型训练优化模型

2. 自学习支持方案的导入和方案的配置，基于方案solution.json训练模型

3. 在定时任务失败的时候发送报警信息给PMS，然后对失败的任务做一些处理，例如再运行3次，如果仍然失败则放弃定时训练任务。对发送信息给PMS的接口，POST JSON文件，查看返回状态，如果返回状态为POST失败，则log输出报警功能异常

4. 模型训练完，需要设置模型的摘要，这部分内容需要提取出模型的重要内容，要了解客户更偏好了解模型的哪些信息

5. 模型需要不断训练到一个我们满意的效果再上线发布，这里要设置训练发布规则，如发布规则的auc要求是0.95，规定了需要训练模型auc到0.95才可以发布

#### 学习圈
1. 提供给小型客户的产品，用于一键式的模型产生以及预估服务，不用开发人员介入，只要普通业务人员就可以构建一个效果显著的机器学习模型

2. 扮演角色，和前端进行交互，调用接口，统计证样本率

3. 有通过四步读取行为数据、反馈数据、模型训练、模型应用

4. 有一个指标页，显示了统计数据指标，从其他接口或者后台读取需要显示的指标，例如特征维度，最近10次模型训练得到的AUC，模型训练时间，使用算法等

5. 关键的模型AUC，需要调用自学习里的接口，获得方案最近10次训练的AUC，可以直观得给用户看到AUC不断的提升

6. 正样本率，需要提交Python脚本给PWS去执行，有诸多难点，一个完整的开发流程，可以看实习下的PDF

7. 在学习圈最初的设计中，只提供4种算法，首先导入行为数据表和反馈数据表，反馈数据表中的id字段要和行为数据表一一对应

8. 假设用户选择的是银行贷款潜在用户，预测的学习圈将行为数据表和反馈数据表拼接在一起，特征抽取。

9. 通过对数据套用4个模型选择效果最好的，将该模型参数填入dag提交给PWS进行初始训练，组装solution.json提交给自学习不断训练出最好的模型

10. 当得到最终模型时，应用模型并预估结果返回给用户

11. 另外用户可以接入kafka数据，后台获取数据通过最新数据训练已有模型

## 学习
### 代码规范、Git开发规范、文档规范、公司的制度
1. Git规范：Commit、分支命名

2. 代码风格：包括Java规范、Shell规范，具体可以看Google Java Style Guide和Google Shell Sytle Guide

3. 文档规范：工程师交流设计，历史内容的保存为未来工程师创造良好的知识资产，在Confluence上创造也能保护知识

4. 公司的制度：公司各部门的工作，部门的关系，上班时间休息时间等

### 微服务、Docker、k8s
1. Docker中的cgroups和namespace：cgroups限制了进程可用资源，包括CPU、内存、阻塞I/O、网络I/O，分配资源给cgroups中的诸多进程。namespace提供进程独立运行的环境隐藏其他namespace的内容，做访问隔离，对资源抽象。

2. Docker会为每个容器创建命名空间和cgroups,Docker和容器一一对应。

3. 容器和外界交流需要存储卷或者端口映射到宿主机。

4. k8s中的Pods本质是将命名空间和cgroups与多个线程结合起来。Pod容器组概念，有依赖的docker instance要放在一个Pod中。Pods和Docker的区别，如果要把几个进程放在同一个容器中运行，需要supervisord这类工具保证进程的持续运行，Docker也只知道supervisord，通过supervisord获取进程信息。

5. Spring Boot适合做微服务，完成简单的功能，省去前期大量的框架搭建时间
### CI/CD自动化版本发布工具
1. CI，每个软件工程师频繁地更新代码到共享位置。开发工作在预定时间中进行集成，自动测试和构建工作

2. CD，快速交付生产阶段的代码，可以每星期发布一次

3. 持续交付意味不断合并代码到主干中去，并自动测试构建。持续部署意味可以不断给客户部署软件，快速解决软件实际存在的问题。

### Spring Boot
1. Spring boot简化配置，加入@ RestController 可以将默认方法中的返回格式都转换成json，SSM中json要加入jar包配置和controller扫描再加入@ ResponseBody注解才可以自动转换为json。

2. 注入类，@Configuration放在类前，@Bean放在方法前

3. filter用于调用日志、排除XSS有威胁的字符、执行权限验证。可以自定义filter接口

4. Redis支持更丰富的数据结构，如hashes，lists，sets，支持数据持久化

### PICO
1. 在先知系统中，特征抽取用来生成多个特征，每列的值都能作为一个特征，增加了特征维度。由此就引出了PICO，分布式存储参数。在特征抽取前有拼表操作增加特征维度。

2. 建议阅读Parameter Server论文来了解PICO

### 列式存储的优点
1. 跳过不符合条件不需要的列，读取需要的列，降低IO数据量

2. 压缩编码可以降低磁盘存储空间。同一列的数据结构相似，压缩编码的效率会很高

3. 读取需要的列，获取更好的扫描性能

### Git
1. 从远程检出分支，Checkout -b <本地分支名> <远程分支名>

2. git log记录本地git commit记录

3. git remote add 可以增加远程仓库到本地，本地仓库就能fetch远程仓库的更新，可以添加多个远程仓库。

4. git push -u origin gaga = git push origin gaga + git branch —set-upstream-to=origin/gaga master，即push本地更新，同时设置origin/gaga为upstream

5. 本地的仓库分支可以关联到多个远程仓库分支(不同仓库)，同样的远程仓库分支可以被多个本地仓库clone

6. 如果本地有分支master在修改，切换分支就需要stash，否则不能checkout到其他的分支，返回之前分支再pop回来

7. 如果对git结构有不了解，可以google图片git

8. 在新创建的分支上开发

9. 注意每天更新分支代码，从上一层/m2-dev中拉更新

### Java
#### Java注解
1. 注解本质就是接口，隐式继承，annotation没有行为只能有数据，实际上是一组键值对，通过解析Class文件把一个annotation需要的键值对找出来

2. 由于注解是接口，但在运行时会获取实现并实现接口所定义的方法，分析源码可以发现，有一个实现了InvocationHandler的类，明显这个类就是动态代理

3. 注解本质是接口，运行期间获取的是接口的代理对象，代理对象通过反射获取这个Handler调用invoce

#### 动态代理
1. public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h),这个方法是为了得到动态的代理对象，接收三个参数，一个是loader:ClassLoader对象，定义由哪个ClassLoader对象对生成的代理对象进行加载

2. Interfaces: 个Interface对象的数组，表示需要为代理对象提供的一组接口，如果提供一组接口，代理对象久宣称实现该类，代理对象就能够调用这组接口方法。h: 一个InvocationHandler对象，表示的是当动态代理对象在调用方法时会关联到哪一个InvocationHandler对象上

3. 每一个动态代理必须实现InvocationHandler这个接口，每个代理类的实例关联到了一个handler。当通过代理对象调用方法时，方法的调用就会被转发为由InvocationHandler这个接口的invoke方法调用

#### DTO(Data Transfer Object)数据传输对象
1. 表现层和应用层通过数据传输对象(DTO)进行交互，数据传输对象是没有行为的POJO对象。它的目的是对领域对象进行数据封装，实现层与层之间的数据传递。领域对象更注重领域，DTO更注重数据。DTO是根据UI需求进行设计，不是根据领域对象设计。


## 项目开发流程
1. 需求评审，开发人员确保需求和合理性和重要程度，将需求拆分到开发人员，估时确定具体任务

2. 任务拆分和评估，对需求评审的结果进行建议和二次评估，得出拆解完的子任务和对应的估点时间表，JIRA派分任务

3. 进入开发，需要产品和技术负责跟进，站会沟通每天做的事，有比较重要的问题需要会议讨论

4. 质量把控，代码作者自己测试以及Code Review，接下来自动化发布工具发布

5. 迭代总结和复盘，验证需求是否达到目的，哪个方案更有效，做的好的地方和不好的地方

* 设计模式

## Others
1. 由于JSON的精简，常用在数据传输领域，wiki上的定义也是数据交换语言。由于XML是完整的标记语言，wiki定义是标记语言，可扩展性强

2. 拦截器，监听器，过滤器

3. flyway迁移数据库

4. 可用性，在一段时间内正常运行和非正常运行百分比。可靠性，如果可用性高，但是问题出现的频率很高，每次解决时间虽然短，可靠性还是很低

5. Linux中运行可执行文件默认到PATH环境变量目录下找，如果要在当前目录下找，需要加./

6. tar.gz一般用在Unix和类Unix下压缩和解压，zip用在windows

7. make工具重新编译构建，MakeFile是构建规则的写入，构建步骤执行顺序，依赖关系等

8. URI http://bitpoetry.io/posts/hello.html#intro; URL http://bitpoetry.io/posts/hello.html; URN bitpoetry.io/posts/hello.html#intro

9. slf4j特性 优势:slf4j不是一个真正的日志实现，而是一个抽象层，允许在后台使用任意一个日志类库，意味着不需要管理多个日志配置;基于占位符，可以用其他内容代替{}; 在得到{}内容时才会构造字符串，减少了内存开销

10. java中... means zero or more String Object

11. Swagger和Postman的使用

12. 镜像(Mirroring)是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。镜像是一种文件存储形式，可以把许多文件做成一个镜像文件，与GHOST等程序放在一个盘里。用GHOST等软件打开后，又恢复成许多文件，RAID 1和RAID 10使用的就是镜像。常见的镜像文件格式有ISO、BIN、IMG、TAO、DAO、CIF、FCD。


## 不足和展望
1. 优点是，这次工作决断的很迅速，没有像在老程那里一样，拖拉了很久，不过没有吸取老程那儿的经验：即先充分联系确认工作是什么

2. 在个人生活及管理上有了长足的进步，在很多方面一个人独立做得不错

3. 工作和学习不一样，中国式的学习是灌输填鸭式的教育，所以导致我们遇到问题不会问，要勤问多思考

4. 工作了不会有人主动来教你，遇到主动教你的善良的人要学会珍惜

5. 基础是工作好的根基，基础打不好工作再多也只是花模刻样

6. 既然决定在Spark大数据研发上一直走下去，就拿出走下去的毅力

7. 不要懊悔来北京这个决定，本身也提供给自己了一次很好的成长机会，在实习后来北京成本会更高

8. 小公司和大公司之间的比较，是大公司赢了。对于应届生来说，在大公司实习更有帮助

9. 在业务不成熟的小公司，要花费大量时间去熟悉业务，而且熟悉当前版本下的业务，很可能第二天就变动了

10. 应届生不应该如此快接触业务，首先在技术上有提高，再做业务，否则没有竞争力，真正的码畜

11. 小公司学的散乱，但做完能对大局有很清楚的了解，大公司专注于一点，在某一点上提升技术，更具针对性

12. 小公司学一圈学的都是皮毛，大公司可能会有比较强螺丝钉的感觉，大公司对人才的培养上肯定更全面，不会像小公司第一天进第二天干活

13. 写代码要了解清楚再写，不然就是做无用功

14. 错误搞不清楚的时候，方法是抛出异常，记录日志，精准定位，而不是调半天自己猜问题在哪，枚举错误。关键是用脑子！

## 生活经验
1. 真正工作了，发票很重要，注意发票的类型以及开具发票的日期

2. 工作中情商很重要，对于无缘无故压上来的任务，要学会拒绝

3. 同事的关系并不能够和同学那样亲近，不要总是试图去问一些私人问题

4. 执行力，未雨绸缪的能力，在面对未来时要充分的考虑，不能太理想化

5. 这次实习太理想化了，把所有的鸡蛋都放在一个篮子里导致最后无路可走，回来复习

6. 要多尝试不同的机会，而不能觉得麻烦逃避，未来的转折和后悔很可能出在这些逃避上

7. 面对机遇时不能操之过急，既要知道机遇是很重要的需要努力去把握，也要知道打无准备的仗本身也是在浪费时间
